
import { GoogleGenAI, Modality } from "@google/genai";
import type { ImageFile } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable is not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

interface GenerateImageParams {
  prompt: string;
  characterImages: ImageFile[];
  styleImage: ImageFile | null;
  baseImage?: ImageFile | null;
  maskImage?: ImageFile | null;
}

export const generateStoryImage = async ({
  prompt,
  characterImages,
  styleImage,
  baseImage,
  maskImage,
}: GenerateImageParams): Promise<string> => {
  try {
    const parts: any[] = [];

    // Order for editing: base image, then mask (if available), then other images, then prompt
    if (baseImage) {
        parts.push({
            inlineData: {
                data: baseImage.base64,
                mimeType: baseImage.mimeType,
            },
        });
    }

    if (maskImage) {
        parts.push({
            inlineData: {
                data: maskImage.base64,
                mimeType: maskImage.mimeType,
            },
        });
    }

    characterImages.forEach(charImg => {
      parts.push({
        inlineData: {
          data: charImg.base64,
          mimeType: charImg.mimeType,
        },
      });
    });

    if (styleImage) {
      parts.push({
        inlineData: {
          data: styleImage.base64,
          mimeType: styleImage.mimeType,
        },
      });
    }

    parts.push({ text: prompt });

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts },
      config: {
        responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
    });
    
    const candidate = response.candidates?.[0];

    if (!candidate || !candidate.content || !candidate.content.parts) {
      let errorMessage = "The model did not return any content.";
      if (candidate?.finishReason && candidate.finishReason !== 'STOP') {
        errorMessage += ` Reason: ${candidate.finishReason}.`;
      }
      if (candidate?.safetyRatings?.some(r => r.blocked)) {
        const blockedCategories = candidate.safetyRatings
          .filter(r => r.blocked)
          .map(r => r.category.replace('HARM_CATEGORY_', ''))
          .join(', ');
        errorMessage += ` The request was blocked for safety reasons (${blockedCategories}). Please adjust your prompt.`;
      }
      throw new Error(errorMessage);
    }

    // Find the first image part in the response
    for (const part of candidate.content.parts) {
      if (part.inlineData) {
        const base64ImageBytes: string = part.inlineData.data;
        return `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
      }
    }

    throw new Error("No image was generated by the model, although a response was received.");

  } catch (error) {
    console.error("Error generating image with Gemini API:", error);
    if (error instanceof Error) {
        if (error.message.includes("Rpc failed due to xhr error")) {
            return Promise.reject(new Error("An API communication error occurred. This may be a temporary issue. Please try again."));
        }
        return Promise.reject(new Error(`Failed to generate image: ${error.message}`));
    }
    return Promise.reject(new Error("An unknown error occurred during image generation."));
  }
};
